// rhea runtime

// todo: debug multiple rerenderings of components on load/initial render

/**
 * A component is any function which can return an HTMLElement.
 */
export type Component = () => HTMLElement | JSX.HTMLElement;

// requestAnimationFrame polyfill
export const requestAnimationFrame =
    window.requestAnimationFrame ||
    // @ts-expect-error
    window.webkitRequestAnimationFrame ||
    // @ts-expect-error
    window.mozRequestAnimationFrame ||
    // @ts-expect-error
    window.msRequestAnimationFrame ||
    function (callback) {
        return setTimeout(callback, 1000 / 60);
    };

/**
 * Components is a list of unique components and the functions that generate them.
 * The key is the function name; **these should be unique**.
 * The value is the latest element generated with the function, and the component function itself.
 * It is recommended that you do not modify this directly.
 */
export const Components: Map<string, { fn: Component; el: HTMLElement | JSX.Element }> = new Map();

/**
 * Index is the index of routes (based on `window.location.pathname`) and the corresponding list of components that it consists of.
 * The key is the route, and the value is the list of components the route is made of.
 * It is recommended that you do not modify this directly.
 */
export const Index: Map<string | RegExp, Set<string>> = new Map();

/**
 * NotFound is the 404 handler for routes not registered using `mount()`
 */
export const NotFound: Set<string> = new Set();

/**
 * Re-renders items whenever the user uses the browser's forward/back buttons
 */
window.addEventListener("popstate", () => {
    emit(document.body, EventType.BeforePageChange);
    render({}, true);
    emit(document.body, EventType.AfterPageChange);
});

/**
 * Registers components.
 * Note that component names must be unique across the entire project.
 * Internally, component names are generated by taking the name of the function and converting it into lowercase.
 * For instance, the component `Navigation` becomes `navigation`.
 * @param elements The components to register.
 */
export const register = (...elements: Component[]) => {
    return elements
        .map(element => {
            const n = element.name.toLowerCase();
            // component already exists
            if (Components.get(n)) {
                throw Error(`component ${n} has already been defined!`);
            } else {
                const ob = {
                    fn: element,
                    el: element.call(null),
                };

                Components.set(element.name.toLowerCase(), ob);
                return true;
            }
        })
        .some(i => (i == false ? false : true));
};

/**
 * Route represents a handler for a given path.
 * Registering `/about` will call the function passed to `mount()` when the user navigates to `/about`.
 */
type Route = string | RegExp | undefined;

/**
 * Registers components for a given route. When the given `route` is navigated to, the `page` callback will be called.
 * @param route The path you want to register the component for
 * @param page The function to call when navigating to the route. This should return the initial components registered on the screen.
 */
export const mount = <T extends { [key: string]: any }>(
    route: Route,
    page: (state?: T) => Component
) => {
    const fn = page.call(null).name.toLowerCase();
    // not found route
    if (route == undefined) {
        NotFound.add(fn);
    } else {
        Index.set(route, new Set<string>().add(fn));
    }
    return true;
};

/**
 * removes all children from the given element
 */
const removeAll = (el: HTMLCollection | NodeList) => {
    requestAnimationFrame(() => {
        Array.from(el).forEach(i => i.parentElement?.removeChild(i));
    });
};

/**
 * Navigates and renders the given page.
 * @param destination The url to go to.
 * Note that you can easily create a new URL class by calling `new URL(href)`, and substituting `href` for the destination,
 * such as one from an `<a>` element.
 */
export const navigate = (destination: URL | string) => {
    const old = window.location.pathname;
    const p: string = typeof destination == "string" ? destination : destination.pathname;
    if (p != old) window.history.pushState("", "", p);
    else if (p == old) return;

    emit(document.body, EventType.Navigation, {
        old,
        next: p,
    });

    render({}, true);

    emit(document.body, EventType.AfterNavigationChange);
};

/**
 * Note that the render event will be scoped to the element is called on, while the before/after page change events
 * are called on `document.body`
 * // todo: fix after/before page change and navigation events
 * @param Initialized Fired when a component is initialised for the first time; note that this is called on `document.body` and its `event.detail` object contains a `component` key
 * @param Navigation Fired immediately after history.pushState() is called
 * @param Render The render event, called whenever a page is rendered.
 * @param Redraw Fired on a component when that component has been redrawn
 * @param GlobalRender Called on `document.body` whenever the page is changed and triggers a complete rerender.
 * @param BeforePageChange Called before a page is changed using the History API
 * @param AfterPageChange Called after a page is changed and rendered.
 * @param AfterNavigationChange Called after a page has been navigated to
 */
export enum EventType {
    Initialized = "initialized",
    Navigation = "navigation",
    Render = "render",
    Redraw = "redraw",
    GlobalRender = "global-render",
    BeforePageChange = "before-page-change",
    AfterPageChange = "after-page-change",
    AfterNavigationChange = "after-navigation-change",
}

// emits an event on the given element
const emit = (el: HTMLElement, event: EventType, detail?: Object) =>
    el.dispatchEvent(new CustomEvent(event.toString(), { detail }));

// helper function for binding `<a>` elements to prevent default navigation behaviour
export const goTo = (url: URL, evt?: Event) => {
    evt?.preventDefault();
    navigate(url);
};

/**
 * Returns a component list for the matching URL path. Note that exact string matches have higher precedence
 * than RegExp matches. A return of `false` indicates that there is no match.
 * @param destination The pathname to check for dynamic paths
 */
const path = (destination = window.location.pathname) => {
    const r = Array.from(Index)?.find(([i, s]) => {
        // exact matches will have precedence
        if (typeof i == "string" && i == destination) {
            return s;
        } else if (i instanceof RegExp && i.test(destination) == true) {
            return s;
        } else {
            return false;
        }
    });
    if (r && r[0]) return r[1];
    else {
        return false;
    }
};

/**
 * Initalisation options for Rhea.
 * @param prerender Prerenders the given routes. The route will be loaded in the background, and swapped if navigated to. If you need real-time results, do not use this.
 * @param cache Maximum number of items to hold in the LRU cache. This functions similarly to `prerender`, but only adds items to the cache once they're navigated to.
 */
interface RenderOptions {
    prerender?: Route[];
    cache?: number;
}

/**
 * Prerender a given route.
 * @param route The route to prerender.
 * @param set If `true`, adds the output to the cache; otherwise, it does not.
 * @returns A `DocumentFragment` containing the generated DOM.
 */
export const prerender = (route: Route, set = false): DocumentFragment => {
    let frag = new DocumentFragment();

    let components: Set<string> | undefined;
    if (route == undefined) {
        components = NotFound;
    } else {
        components = Index.get(route);
    }

    // appends hydrated components to output fragment
    const h = () => {
        if (components == undefined) return;
        components.forEach(i => {
            const cmp = Components.get(i);
            if (cmp) {
                frag.appendChild(hydrate(cmp.fn));
            } else {
                throw Error(`component ${i} is not registered in the component registry`);
            }
        });
    };

    if (components != undefined) {
        h();
    } else {
        if (route instanceof RegExp) {
            Index.forEach((_, v) => {
                // checks to ensure two regexes are mostly the same
                if (v instanceof RegExp) {
                    if (
                        v.source === route.source &&
                        v.global === route.global &&
                        v.ignoreCase === route.ignoreCase &&
                        v.multiline === route.multiline
                    ) {
                        components = Index.get(v);
                        h();
                    }
                }
            });
        } else if (typeof route == "string") {
            Index.forEach((_, v) => {
                if (v instanceof RegExp && v.test(route) == true) {
                    components = Index.get(v);
                    h();
                }
            });
        }
    }

    if (set == true && cache.has(route) == false) cache.set(route, frag);

    return frag;
};

/**
 * Cache of route DOMs.
 * It is recommended you don't set this directly.
 */
export const cache: Map<Route, DocumentFragment> = new Map();

/**
 * Renders all components.
 * @param prev Whether or not render is being called from a popstate event so that the DOM can be cleared. Do not set this parameter.
 */
// todo: figure out a way to diff components on current page and next page, so that same components will not be removed
export const render = (options?: RenderOptions, prev = false, route = window.location.pathname) => {
    document.body.querySelectorAll<HTMLElement>("a[href]").forEach(i => {
        i.addEventListener("click", evt => {
            if (i.dataset.bound) return;
            let href = (i as HTMLAnchorElement).href;
            if (href.startsWith("#")) href = window.location.href + href;

            goTo(new URL(href), evt);
        });
    });

    // removes all previous components
    if (prev) removeAll(document.body.querySelectorAll("[data-component]"));

    // draws components to screen
    const r = (components: Set<string>, route?: Route) => {
        let frag = new DocumentFragment();

        const cached = cache.get(route);
        if (cached == undefined) {
            components.forEach(i => {
                const cmp = Components.get(i);
                if (cmp) {
                    const slot = document.body.querySelector(
                        `slot[component="${cmp.fn.name.toLowerCase()}"]`
                    );

                    if (slot) requestAnimationFrame(() => slot.appendChild(hydrate(cmp.fn)));
                    else frag.appendChild(hydrate(cmp.fn));
                } else {
                    throw Error(`component ${i} is not registered`);
                }
            });
        } else {
            frag = cached;
        }

        requestAnimationFrame(() => {
            document.body.appendChild(frag);
            emit(document.body, EventType.GlobalRender);
        });
    };

    if (options?.prerender)
        options.prerender.forEach(i =>
            // @ts-ignore
            window.requestIdleCallback(() => prerender(i, true), {
                timeout: 100,
            })
        );

    const components = path(route);

    // no route found
    if (components == false && NotFound.size == 0) {
        throw Error(`${window.location.pathname} is not a registered route`);
    } else if (NotFound.size != 0 && components == false) {
        // no route found, but there's a valid 404 handler
        r(NotFound, undefined);
        return true;
    } else if (components != false) {
        // render the found route
        r(components);
        return true;
    } else {
        // voodoo
        throw Error(`${window.location.pathname} is an invalid route`);
    }
};

/**
 * Generates and hydrates a given component
 * @param i The function to generate the component from
 * @param name Name of the component
 */
export const hydrate = (i: Component) => {
    const $el = i?.call(null) as HTMLElement;
    emit(document.body, EventType.Initialized, {
        component: i.name.toLowerCase(),
    });

    const kids: HTMLElement[] = Array.from($el.children).map(el => el as HTMLElement);

    const hasLink = kids.filter(
        (kid: HTMLElement) =>
            kid instanceof HTMLAnchorElement &&
            kid.href &&
            (new URL(kid.href).origin.startsWith(window.location.origin) ||
                kid.href.startsWith("#")) == true
    );

    if (hasLink.length >= 1) {
        hasLink.forEach(i =>
            i.addEventListener("click", evt => {
                if (i.dataset.bound) return;
                let href = (i as HTMLAnchorElement).href;
                if (href.startsWith("#")) href = window.location.href + href;

                goTo(new URL(href), evt);
            })
        );
    }

    if (
        $el instanceof HTMLAnchorElement &&
        new URL($el.href).origin.startsWith(window.location.origin) == true
    ) {
        $el.addEventListener("click", evt => {
            if ($el.dataset.bound) return;
            $el.dataset.bound = "true";
            let href = ($el as HTMLAnchorElement).href;
            if (href.startsWith("#")) href = window.location.href + href;

            goTo(new URL(href), evt);
        });
    }

    $el.dataset.component = i.name.toLowerCase();

    const c = Components.get(i.name.toLowerCase());

    if (c) Components.set(i.name.toLowerCase(), { fn: c.fn, el: $el });

    return $el;
};

/**
 * Re-renders a single component
 * @param component The component to redraw
 */
export const redraw = (cmp: string | Component) => {
    let component = cmp;
    if (typeof cmp == "function") {
        component = cmp.name.toLowerCase();
    }

    if (typeof component == "function") {
        component = component.name.toLowerCase();
    }

    const cmpFunction = Components.get(component);
    if (cmpFunction) {
        const { el, fn } = cmpFunction;

        requestAnimationFrame(() => (el as HTMLElement).replaceWith(hydrate(fn)));
        emit(el as HTMLElement, EventType.Redraw);
    } else {
        throw Error(`component ${component} is not registered`);
    }
};

export * from "../std/index";
